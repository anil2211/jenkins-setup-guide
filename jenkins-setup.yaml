# session 41 25/10/2025(nginx-frontend-app)
ğŸ” CI/CD Automation Tools Overview
Popular CI/CD tools:
GitLab CI/CD
GitHub Actions
Jenkins
Bitbucket Pipelines
Azure DevOps Pipelines
AWS CodePipeline

ğŸ‘‰ In your learning path:
GitLab
GitHub Actions
Jenkins (main focus)

ğŸ”§ What is Jenkins?
Open-source (free to use) CI/CD automation tool
Written in Java
Used for:
Continuous Integration (CI)
Continuous Deployment / Delivery (CD)

ğŸ”„ CI/CD Concepts
Continuous Integration (CI)
Developers frequently commit code to a shared repository (GitHub)
Jenkins automatically:
Pulls code
Builds it
Runs tests

Continuous Deployment (CD)
After successful build & tests:
Application is automatically deployed to servers

ğŸ“Œ CI/CD Flow (High Level)
Developer
   |
   | (code commit)
   v
GitHub Repository
   |
   v
Jenkins
   |
   |--> Build
   |--> Test
   |--> Deploy
   |
   |--> Logs
   |--> Notifications
   |--> Email alerts

ğŸ§± Key Jenkins Components
1ï¸âƒ£ Jenkins Controller (Master)
Central server
Manages:
Jobs
Pipelines
Plugins
Credentials
Agents

2ï¸âƒ£ Jenkins Agents (Nodes / Slaves)
Execute jobs
Used for:
Distributed builds
Scaling
Different environments (Linux, Windows, Docker)

3ï¸âƒ£ Plugins
Extend Jenkins functionality
Examples:
Git
GitHub
Pipeline
Email Extension
Docker

4ï¸âƒ£ Credential Manager
Securely stores:
GitHub tokens
SSH keys
Passwords
Cloud credentials

5ï¸âƒ£ Pipelines
CI/CD defined as code
Written in Groovy
Stored as:
Jenkinsfile

ğŸ“„ Jenkinsfile (Pipeline as Code)
Written in Groovy
Two types:
Declarative
Scripted

pipeline {
    agent any
    stages {
        stage('Build') {
            steps {
                echo 'Building...'
            }
        }
        stage('Test') {
            steps {
                echo 'Testing...'
            }
        }
        stage('Deploy') {
            steps {
                echo 'Deploying...'
            }
        }
    }
}


â˜ï¸ Jenkins Setup on AWS (EC2)
Step 1ï¸âƒ£ Launch EC2 Instance
OS: Ubuntu
Instance type: t2.micro (free tier)
Create & download PEM key

Step 2ï¸âƒ£ Set Permission to PEM Key (Local Machine)
chmod 400 jenkins-training.pem

Step 3ï¸âƒ£ Login to EC2
ssh -i "jenkins-training.pem" ubuntu@ec2-43-204-107-152.ap-south-1.compute.amazonaws.com

âš™ï¸ Jenkins Installation (Official Method â€“ LTS)
Step 4ï¸âƒ£ Update System
sudo apt update

Step 5ï¸âƒ£ Install Java (Required)
sudo apt install fontconfig openjdk-21-jre
java -version

Step 6ï¸âƒ£ Add Jenkins Repository (LTS)
sudo wget -O /etc/apt/keyrings/jenkins-keyring.asc \
https://pkg.jenkins.io/debian-stable/jenkins.io-2023.key

echo "deb [signed-by=/etc/apt/keyrings/jenkins-keyring.asc] https://pkg.jenkins.io/debian-stable binary/" | sudo tee /etc/apt/sources.list.d/jenkins.list > /dev/null

Step 7ï¸âƒ£ Install Jenkins
sudo apt update
sudo apt install jenkins

Step 8ï¸âƒ£ Start Jenkins
sudo systemctl enable jenkins
sudo systemctl start jenkins
sudo systemctl status jenkins

Step 9ï¸âƒ£ Get Initial Admin Password
sudo cat /var/lib/jenkins/secrets/initialAdminPassword

ğŸŒ Jenkins UI Access
Step ğŸ”Ÿ Open Port 8080 (AWS Security Group)
EC2 â†’ Security Groups
Inbound rule:
Port: 8080
Source: Your IP / 0.0.0.0/0 (for training)

Step 1ï¸âƒ£1ï¸âƒ£ Access Jenkins in Browser
http://43.204.107.152:8080/

Paste the initial admin password and complete setup.

âœ… CI/CD concepts
âœ… Jenkins architecture
âœ… Jenkins installation on AWS EC2
âœ… Jenkins UI access
âœ… Foundation for pipelines & automation



# session 42 28/10/2025()
ğŸ”§ EC2 Preparation â€“ Install Docker
Prepare the EC2 instance by installing Docker so Jenkins can build and run containers.

sudo apt update
sudo apt install docker.io -y

Enable and start Docker:

sudo systemctl enable docker
sudo systemctl start docker
sudo systemctl status docker


Allow Jenkins to access Docker:

sudo usermod -aG docker jenkins
sudo systemctl restart jenkins


ğŸ‘‰ This allows Jenkins jobs to execute Docker commands without sudo.
ğŸ§© Jenkins Job Types
To create a job:
Jenkins Dashboard â†’ New Item
Enter item name: New-Project

Select an item type

ğŸ“Œ Available Job Types
1ï¸âƒ£ Freestyle Project
Simple, shell-based jobs
Suitable for small projects
Commands written in Execute Shell

2ï¸âƒ£ Pipeline
Code-based automation
CI/CD defined as code (Jenkinsfile)
Automatically triggers on code changes
Pipeline Types:
Declarative â€“ Simple, readable, structured (recommended)
Scripted â€“ Advanced logic, loops, conditions

3ï¸âƒ£ Multi-Configuration Project (Matrix Project)
Same job runs in multiple environments
Example:
Different OS versions
Multiple JDK or Node versions
Supports parallel execution

4ï¸âƒ£ Folder
Organizes jobs in a hierarchical structure
Useful when:
Multiple teams work on one Jenkins instance
Projects need logical grouping
Improves navigation and management

5ï¸âƒ£ Multibranch Pipeline
Automatically creates pipelines for each branch
Detects branches from a GitHub repository
Each branch has its own Jenkinsfile

6ï¸âƒ£ Organization Folder
Scans an entire GitHub organization
Automatically creates:
Multibranch pipelines for each repository
Used in large enterprise setups

ğŸ› ï¸ Freestyle Project â€“ Hands-on CI/CD Example
Step 1ï¸âƒ£ Create Freestyle Project
Select Freestyle Project
Click OK
Step 2ï¸âƒ£ Configure Project
Add Description
Select GitHub Project
Enter GitHub Repository URL
Credentials: None (for public repo)
Branch: master or main

Step 3ï¸âƒ£ Enable GitHub Webhook Trigger
Check:
GitHub hook trigger for GITScm polling
Step 4ï¸âƒ£ Build Steps â†’ Execute Shell
Add the following shell script:

#!/bin/bash
set -e

echo "Building Docker image"
docker build -t nginx-frontend:latest .

echo "Stopping old container if any"
docker stop nginx-frontend-app || true
docker rm nginx-frontend-app || true

echo "Running new container on port 9090"
docker run -d --name nginx-frontend-app -p 9090:80 nginx-frontend:latest

echo "Container status"
docker ps -a

echo "Last 20 log lines"
docker logs --tail=20 nginx-frontend-app

Step 5ï¸âƒ£ Save & Build

Click Save
Click Build Now
Monitor:
Console Output
Logs

Success / Failure status

ğŸ”” GitHub Webhook Configuration
In GitHub Repository:
Settings â†’ Webhooks â†’ Add webhook
Payload URL:
http://<EC2-PUBLIC-IP>:8080/github-webhook/

Example:
http://3.109.187.XXX:8080/github-webhook/

Content Type:
application/json

Events:
Just the push event
ğŸ”„ End-to-End CI/CD Flow
Developer commits code
        â†“
GitHub Repository
        â†“ (Webhook)
Jenkins Freestyle Job
        â†“
Docker Build
        â†“
Docker Deploy
        â†“
Application Running on EC2 (Port 9090)


ğŸ“Š Jenkins Dashboard Capabilities
View job status
Console logs
Build history
Failure root cause
Success confirmation
ğŸ“© Notifications (Optional Enhancements)
Email notifications for:
Build success
Build failure
Slack / Teams integration
Advanced reporting with plugins
âœ… What This Setup Demonstrates
âœ” Jenkins Freestyle CI/CD
âœ” Docker-based deployment
âœ” GitHub webhook automation
âœ” Real-time build logs
âœ” Basic DevOps workflow

enable all github plugin and add webhook triggers 


# session 43 28/10/2025 (notes-app-pipeline)**********************************************************************************************
project - satyam-git notes-app

ğŸš€ Jenkins Pipeline Using Groovy (Declarative Pipeline)
Pipeline Overview
Project: Notes App
Pipeline Type: Declarative

Purpose:
Automate CI/CD using Jenkins Pipeline:
Checkout code
Build Docker image
Stop old container
Run new container
Verify deployment

ğŸ“ Jenkins Job Configuration

Jenkins Dashboard â†’ New Item
Enter name: notes-app-pipeline
Select Pipeline
Description:
Notes App CI/CD Pipeline using Docker

Scroll to Pipeline

Select:

Definition: Pipeline script

ğŸ“œ Declarative Pipeline Script (Groovy)

pipeline {
    agent any

    environment {
        IMAGE_NAME     = "notes-app:latest"
        CONTAINER_NAME = "notes-app"
        PORT           = "9092"
        HOST           = "3.109.187.88"
    }

    stages {

        stage('Checkout Code') {
            steps {
                git branch: 'master',
                    url: 'https://github.com/your-org/notes-app.git'
            }
        }

        stage('Build Docker Image') {
            steps {
                sh '''
                    echo "===== Building Docker Image ====="
                    docker build -t $IMAGE_NAME .
                '''
            }
        }

        stage('Stop Old Container') {
            steps {
                sh '''
                    echo "===== Stopping Old Container ====="
                    docker stop $CONTAINER_NAME || true
                    docker rm $CONTAINER_NAME || true
                '''
            }
        }

        stage('Run New Container') {
            steps {
                sh '''
                    echo "===== Running New Container ====="
                    docker run -d \
                      --name $CONTAINER_NAME \
                      -p $PORT:80 \
                      $IMAGE_NAME
                '''
            }
        }

        stage('Verify Deployment') {
            steps {
                sh '''
                    echo "===== Verifying Application ====="
                    sleep 10
                    curl -s http://$HOST:$PORT | head -n 20
                '''
            }
        }
    }

    post {
        success {
            echo "âœ… Notes app deployed successfully!"
            echo "ğŸŒ Access URL: http://$HOST:$PORT"
        }
        failure {
            echo "âŒ Build or deployment failed. Check Jenkins logs."
        }
    }
}


I have multiple app in this git repo then the code is different
pipeline {
    agent any

    environment {
        APP_DIR        = "notes-app"
        IMAGE_NAME     = "notes-app:latest"
        CONTAINER_NAME = "notes-app"
        PORT           = "9092"
        HOST           = "3.109.187.88"
    }

    stages {

        stage('Checkout Code') {
            steps {
                git branch: 'main',
                    url: 'https://github.com/anil2211/jenkins-setup-guide.git'
            }
        }

        stage('Build Docker Image') {
            steps {
                dir("${APP_DIR}") {
                    sh '''
                        echo "===== Building Docker Image ====="
                        docker build -t $IMAGE_NAME .
                    '''
                }
            }
        }

        stage('Stop Old Container') {
            steps {
                sh '''
                    echo "===== Stopping Old Container ====="
                    docker stop $CONTAINER_NAME || true
                    docker rm $CONTAINER_NAME || true
                '''
            }
        }

        stage('Run New Container') {
            steps {
                sh '''
                    echo "===== Running New Container ====="
                    docker run -d \
                      --name $CONTAINER_NAME \
                      -p $PORT:80 \
                      $IMAGE_NAME
                '''
            }
        }

        stage('Verify Deployment') {
            steps {
                sh '''
                    echo "===== Verifying Application ====="
                    sleep 10
                    curl -s http://$HOST:$PORT | head -n 20
                '''
            }
        }
    }

    post {
        success {
            echo "âœ… Notes app deployed successfully!"
            echo "ğŸŒ Access URL: http://$HOST:$PORT"
        }
        failure {
            echo "âŒ Build or deployment failed. Check Jenkins logs."
        }
    }
}



ğŸ” Explanation of Pipeline Sections
agent any
Pipeline can run on any available Jenkins agent
environment
Centralized environment variables
Easy to update image name, port, host without editing logic
stages
Each stage performs a single responsibility:
Checkout Code
Pulls source code from GitHub
Build Docker Image
Builds Docker image from Dockerfile
Stop Old Container
Gracefully stops and removes old container
|| true prevents pipeline failure if container doesnâ€™t exist
Run New Container
Deploys new container on specified port
Verify Deployment
Uses curl to validate application response
post Section
Executes actions after pipeline completion
Condition	Action
success	Success message + app URL
failure	Failure message + log reference

ğŸ”„ CI/CD Flow (Pipeline-Based)
GitHub Commit
     â†“
Jenkins Pipeline
     â†“
Docker Build
     â†“
Docker Deploy
     â†“
Application Live on EC2

âœ… Advantages of Pipeline Over Freestyle
âœ” Pipeline as Code
âœ” Version controlled
âœ” Better readability
âœ” Scalable & reusable
âœ” Industry standard

â–¶ï¸ Run the Pipeline
Click Save
Click Build Now
Monitor:
Stage-wise execution
Console output
Success / failure status


# session 44 
jenkins credential 
use the docker hub

add credentials into jenkins

open docker hub -accounts-personal  access tokens-generate new token


now open jenkins- credential-global credentials-add credentilas
new credential-kind-username and password
username
password
id 
Description

pipeline {
    agent any

    environment {
        APP_DIR        = "notes-app"
        IMAGE_NAME     = "notes-app:latest"
        CONTAINER_NAME = "notes-app"
        PORT           = "9092"
        HOST           = "3.109.187.88"
        DOCKER_USER    = "username"
    }

    stages {

        stage('Checkout Code') {
            steps {
                git branch: 'main',
                    url: 'https://github.com/anil2211/jenkins-setup-guide.git'
            }
        }

        stage('Build Docker Image') {
            steps {
                dir("${APP_DIR}") {
                    sh '''
                        echo "===== Building Docker Image ====="
                        docker build -t $IMAGE_NAME .
                    '''
                }
            }
        }
        stage('push to docker hub'){
        steps{
                  withCredentials([usernamePassword(
        
                        credentialsId: 'Docker_hub_id_pwd',
                        usernameVariable: 'DOCKER_USERNAME',
                        passwordVariable: 'DOCKER_PASSWORD'
                        )])    {
                            sh ''' 
                            echo "==========logging in to docker hub "
                            echo $DOCKER_PASS | docker login -u $DOCKER_USER --password-stdin
                            '''
                            echo "====tagging image======"
                            docker tag $IMAGE_NAME $DOCKER_USER/$IMAGE_NAME
                            echo "=====pushing image to docker hub=====" 
                            docker push $DOCKER_USER/$IMAGE_NAME
                            ''' 
                        }               
                        }
                           }
        stage('Stop Old Container') {
            steps {
                sh '''
                    echo "===== Stopping Old Container ====="
                    docker stop $CONTAINER_NAME || true
                    docker rm $CONTAINER_NAME || true
                '''
            }
        }

        stage('Run New Container') {
            steps {
                sh '''
                    echo "===== Running New Container ====="
                    docker run -d \
                      --name $CONTAINER_NAME \
                      -p $PORT:80 \
                      $IMAGE_NAME
                '''
            }
        }

        stage('Verify Deployment') {
            steps {
                sh '''
                    echo "===== Verifying Application ====="
                    sleep 10
                    curl -s http://$HOST:$PORT | head -n 20
                '''
            }
        }
    }

    post {
        success {
            echo "âœ… Notes app deployed successfully!"
            echo "ğŸŒ Access URL: http://$HOST:$PORT"
        }
        failure {
            echo "âŒ Build or deployment failed. Check Jenkins logs."
        }
    }
}



# session 45 
jenkins =>master and slave 
2 instances 
launch insatance on aws =>jenkins agents
launch insatnce master-
install jenkins docker java on both instance
on slave instl docker java

on slave mkdir -p /home/ubuntu/jenkins
ls

on master
ls -a
cd .
cd .ssh/
ls
ssh-keygen
ls
cat id_ed255519.pub
copy that key

on slave node
ls -a
cd .
cd .ssh/
ls
sudo vim authrosed-key
paste the key copy from the master
cat authorised-key

sudo usermod -aG docker ubuntu
newgrp docker


no on master node open jenkins on localhost
new-node=>jenkin-agent
permanent agent
name ,description,number of executors-1,remote root directory-paste the paste of slave
/home/ubuntu/jenkins
labels-dev

launch method-launch agents via ssh
host-paste ip of slave instance

credentials-add credentials
kind-SSH username with private key
id=>dev-agent-key
description=>private key for dev
username =>username

private key=>copy the private key from the master node

save it

same java version and docker on master and slave node

in side jenkins
on master node

****************************************************************************************
Jenkins Masterâ€“Agent (Slave) Setup on AWS (Step-by-Step)
Architecture Overview
Component	Purpose
Jenkins Master	Controls pipelines, scheduling, UI
Jenkins Agent (Slave)	Executes jobs (Docker build, push, run)
AWS EC2	Infrastructure
Docker	Application containerization
SSH	Secure Master â†’ Agent communication

Step 1: Launch AWS EC2 Instances
1ï¸âƒ£ Create 2 EC2 instances
OS: Ubuntu 22.04
Instance Type: t2.medium (recommended)
Security Group:
Port 22 â†’ SSH
Port 8080 â†’ Jenkins UI
Port 9092 â†’ Application access

Instance	Purpose
Instance 1	Jenkins Master
Instance 2	Jenkins Agent (Slave)

Step 2: Install Required Software

ğŸ”¹ On Master & Agent

sudo apt update -y
sudo apt install -y openjdk-17-jdk docker.io

Enable Docker:
sudo systemctl start docker
sudo systemctl enable docker

Add user to Docker group:
sudo usermod -aG docker ubuntu
newgrp docker

âš ï¸ Important:
Java & Docker versions must be same on master and agent to avoid pipeline failures.

Step 3: Install Jenkins on Master Node

curl -fsSL https://pkg.jenkins.io/debian/jenkins.io.key | sudo tee \
/usr/share/keyrings/jenkins-keyring.asc > /dev/null

echo deb [signed-by=/usr/share/keyrings/jenkins-keyring.asc] \
https://pkg.jenkins.io/debian binary/ | sudo tee \
/etc/apt/sources.list.d/jenkins.list > /dev/null

sudo apt update
sudo apt install -y jenkins
sudo systemctl start jenkins
sudo systemctl enable jenkins

Access Jenkins:
http://<MASTER_PUBLIC_IP>:8080

Step 4: Prepare Jenkins Agent (Slave)

Create Jenkins working directory
mkdir -p /home/ubuntu/jenkins
ls /home/ubuntu

Step 5: Configure SSH Key-Based Authentication

ğŸ”¹ On Master

cd ~/.ssh
ssh-keygen
ls
cat id_ed25519.pub
ğŸ“‹ Copy the public key
ğŸ”¹ On Agent
cd ~/.ssh
sudo vim authorized_keys

Paste Masterâ€™s public key, then:
cat authorized_keys

Step 6: Add Jenkins Agent in Jenkins UI

Jenkins Dashboard â†’ Manage Jenkins
â¡ Manage Nodes and Clouds
â¡ New Node

Node Configuration
Field	Value
Node Name	jenkins-agent
Type	Permanent Agent
Executors	1
Remote Root Dir	/home/ubuntu/jenkins
Labels	dev

Launch Method: Launch agent via SSH
Field	Value
Host	<AGENT_PRIVATE_IP>
Credentials	Add New
Kind	SSH Username with Private Key
ID	dev-agent-key
Username	ubuntu
Private Key	Paste Masterâ€™s private key

âœ… Save â†’ Jenkins connects agent automatically

Step 7: Verify Agent Connection
Node status should be Connected
Logs should show:
Agent successfully connected

Jenkins Declarative Pipeline (Corrected & Improved)
ğŸ”¥ Fixed issues:
Correct agent syntax
Fixed Docker login variable mismatch
Proper shell quoting
Correct Docker Hub push flow

jenkinsfile
pipeline {
    agent { label 'dev' }

    environment {
        APP_DIR        = "notes-app"
        IMAGE_NAME     = "notes-app"
        IMAGE_TAG      = "latest"
        CONTAINER_NAME = "notes-app"
        PORT           = "9092"
        HOST           = "3.109.187.88"
        DOCKER_USER    = "your_dockerhub_username"
    }

    stages {

        stage('Checkout Code') {
            steps {
                git branch: 'main',
                url: 'https://github.com/anil2211/jenkins-setup-guide.git'
            }
        }

        stage('Build Docker Image') {
            steps {
                dir("${APP_DIR}") {
                    sh '''
                        echo "===== Building Docker Image ====="
                        docker build -t $IMAGE_NAME:$IMAGE_TAG .
                    '''
                }
            }
        }

        stage('Push Image to Docker Hub') {
            steps {
                withCredentials([
                    usernamePassword(
                        credentialsId: 'Docker_hub_id_pwd',
                        usernameVariable: 'DOCKER_USERNAME',
                        passwordVariable: 'DOCKER_PASSWORD'
                    )
                ]) {
                    sh '''
                        echo "===== Logging into Docker Hub ====="
                        echo $DOCKER_PASSWORD | docker login -u $DOCKER_USERNAME --password-stdin

                        echo "===== Tagging Image ====="
                        docker tag $IMAGE_NAME:$IMAGE_TAG $DOCKER_USERNAME/$IMAGE_NAME:$IMAGE_TAG

                        echo "===== Pushing Image ====="
                        docker push $DOCKER_USERNAME/$IMAGE_NAME:$IMAGE_TAG
                    '''
                }
            }
        }

        stage('Stop Old Container') {
            steps {
                sh '''
                    docker stop $CONTAINER_NAME || true
                    docker rm $CONTAINER_NAME || true
                '''
            }
        }

        stage('Run New Container') {
            steps {
                sh '''
                    docker run -d \
                    --name $CONTAINER_NAME \
                    -p $PORT:80 \
                    $IMAGE_NAME:$IMAGE_TAG
                '''
            }
        }

        stage('Verify Deployment') {
            steps {
                sh '''
                    sleep 10
                    curl -s http://$HOST:$PORT | head -n 20
                '''
            }
        }
    }

    post {
        success {
            echo "âœ… Notes app deployed successfully!"
            echo "ğŸŒ Access URL: http://$HOST:$PORT"
        }
        failure {
            echo "âŒ Deployment failed. Check logs."
        }
    }
}

Interview Explanation (How to Answer)

Q: Why Masterâ€“Agent architecture?
âœ” Load distribution
âœ” Secure execution
âœ” Scalability
âœ” Resource isolation

Q: Why SSH-based agent?
âœ” Simple
âœ” Secure
âœ” Widely used in production

Q: Why labels?
âœ” Control job execution on specific nodes

Final Result
âœ” Jenkins Master manages pipelines
âœ” Agent builds & deploys Docker containers
âœ” Docker image pushed to Docker Hub
âœ” Application deployed automatically


*******session 46*********************************************************************
email notificationa
plugin email extensions,mailer plugin
open gmail->accounts->security->app password
open jenkins-> system->extended email notification
SMTP server-smtp.gmail.com
port 465
add credential-username with password
username-email id
password-copy from the gmail,the password which we create for the app
save

email-notifications
smtp- smtp.gmail.com
use smtp authentification
username-email and password

test it

save it 
now run pipeline


script 

    post {
        success {
            echo "âœ… Notes app deployed successfully!"
            echo "ğŸŒ Access URL: http://$HOST:$PORT"
            emailext(
            subject:"build successful",
            body: "congrtas build was successful"
            to: "email-id"
            )
        }
        failure {
            echo "âŒ Deployment failed. Check logs."
            emailext(
            subject:"build failed",
            body: "congrtas build was failed"
            to: "email-id"
            )
        }



add webhook on github with the master node ip


plugin
role based autorization strategy

user->create user

security-authrization->matrix nbased security
add user


***************************8session 47**********************
gitlab
